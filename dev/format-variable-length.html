
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Proposal for a persistent format that can include variable length objects &mdash; Blaze 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/bootstrap-2.2.1.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/bootstrap-responsive-2.2.1.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/bootstrap-2.2.1.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <script type="text/javascript" src="_static/js/bootstrap-scrollspy.js"></script>
    <script type="text/javascript" src="_static/js/bootstrap-affix.js"></script>
    <link rel="top" title="Blaze 0.3.0 documentation" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

<div class="container">
  <!-- This is copied from /web, find better solution -->
  <div class="masthead">
    <ul class="nav nav-pills pull-right">
        <li>
            <a href="/index.html"><i class="icon-home"></i> Blaze</a>
        </li>
        
        <li class="active">
            <a href="/docs/index.html"><i class="icon-book"></i> Documentation</a>
        </li>
        
        <li>
            <a href="/examples.html"><i class="icon-ok"></i> Examples</a>
        </li>
        
        <li>
            <a href="http://github.com/ContinuumIO/blaze-core"><i class="icon-download"></i> Source</a>
        </li>
        
        <li>
            <a href="/vision.html"><i class="icon-star"></i> Vision</a>
        </li>
        
        <li>
            <a href="/people.html"><i class="icon-user"></i> People</a>
        </li>
        
        <li>
            <a href="http://groups.google.com/a/continuum.io/forum/#!forum/blaze-dev"><i class="icon-envelope"></i> Mailing List</a>
        </li>
    </ul>
    <h3 class="muted"><img src="_static/img/logo.png">Blaze</h3>
  </div>

  <hr>

  <div class="row">
      <div class="span3">
         <ul id="nav" class="nav nav-list" data-spy="affix" data-offset-top="200"><li><a href="index.html"><b>Index</b></a></li>
<ul>
<li><a class="reference internal" href="#">Proposal for a persistent format that can include variable length objects</a><ul>
<li><a class="reference internal" href="#monolithic-format">Monolithic format</a><ul>
<li><a class="reference internal" href="#header-format">Header format</a><ul>
<li><a class="reference internal" href="#description-of-the-header-entries">Description of the header entries</a></li>
<li><a class="reference internal" href="#description-of-the-metadata-section">Description of the metadata section</a></li>
<li><a class="reference internal" href="#description-of-the-offsets-entries-for-data-items">Description of the offsets entries for data items</a></li>
<li><a class="reference internal" href="#description-of-the-chunk-format">Description of the chunk format</a></li>
<li><a class="reference internal" href="#overhead">Overhead</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

         </ul>
      </div>
      <div class="span9">
          
  <div class="section" id="proposal-for-a-persistent-format-that-can-include-variable-length-objects">
<h1>Proposal for a persistent format that can include variable length objects<a class="headerlink" href="#proposal-for-a-persistent-format-that-can-include-variable-length-objects" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Francesc Alted</td>
</tr>
</tbody>
</table>
<p>This document proposes a new version of the Bloscpack format (<a class="footnote-reference" href="#id2" id="id1">[1]</a>)
that accommodates variable length data.  For simplicity, I will be focusing
on the monolithic flavor of the original proposal.  A proposal for the
chunked flavor should follow as soon as we reach an agreement.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://github.com/esc/bloscpack">https://github.com/esc/bloscpack</a></td></tr>
</tbody>
</table>
<div class="section" id="monolithic-format">
<h2>Monolithic format<a class="headerlink" href="#monolithic-format" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-format">
<h3>Header format<a class="headerlink" href="#header-format" title="Permalink to this headline">¶</a></h3>
<p>The design goals of the header format are to contain as much
information as possible to achieve interesting things in the future
and to be as general as possible so as to ensure compatibility with
the chunked persistence format.</p>
<p>The following ASCII representation shows the layout of the header:</p>
<div class="highlight-python"><pre>|-0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-|-9-|-A-|-B-|-C-|-D-|-E-|-F-|
| b   l   p   k | ^ | ^ | ^ | ^ |   chunk-size  |  last-chunk   |
                  |   |   |   |
      version ----+   |   |   |
      options --------+   |   |
     checksum ------------+   |
     typesize ----------------+

|-0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-|-9-|-A-|-B-|-C-|-D-|-E-|-F-|
|            nchunks            |   meta-size   |   RESERVED    |</pre>
</div>
<p>The first 4 bytes are the magic string <tt class="docutils literal"><span class="pre">blpk</span></tt>. Then there are 4
bytes, the first three are described below and the last one is
reserved. This is followed by 4 bytes for the <tt class="docutils literal"><span class="pre">chunk-size</span></tt>, another
4 bytes for the <tt class="docutils literal"><span class="pre">last-chunk-size</span></tt> and 8 bytes for the number of
chunks. Finally, the <tt class="docutils literal"><span class="pre">meta-size</span></tt> accounts for the amount of bytes
that takes the metadata to be stored.  The last 4 bytes are reserved
for use in future versions of the format.</p>
<div class="section" id="description-of-the-header-entries">
<h4>Description of the header entries<a class="headerlink" href="#description-of-the-header-entries" title="Permalink to this headline">¶</a></h4>
<p>All entries are little-endian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">version:</th><td class="field-body"><p class="first">(<tt class="docutils literal"><span class="pre">uint8</span></tt>)
format version of the Bloscpack header, to ensure exceptions in case of
forward incompatibilities.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">options:</th><td class="field-body"><p class="first">(<tt class="docutils literal"><span class="pre">bitfield</span></tt>)
A bitfield which allows for setting certain options in this file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">bit</span> <span class="pre">0</span> <span class="pre">(0x01)</span></tt>:</th><td class="field-body">If the offsets to the chunks are present in this file.</td>
</tr>
<tr class="field-even field"><th class="field-name"><tt class="docutils literal"><span class="pre">bit</span> <span class="pre">1</span> <span class="pre">(0x02)</span></tt>:</th><td class="field-body">If metadata is present in this file.</td>
</tr>
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">bit</span> <span class="pre">2</span> <span class="pre">(0x04)</span></tt>:</th><td class="field-body">If this dataset is variable length.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field-even field"><th class="field-name">checksum:</th><td class="field-body"><p class="first">(<tt class="docutils literal"><span class="pre">uint8</span></tt>)
The checksum used. The following checksums, available in the python
standard library should be supported. The checksum is always computed on
the compressed data and placed after the chunk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">0</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">no</span> <span class="pre">checksum</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name"><tt class="docutils literal"><span class="pre">1</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">zlib.adler32</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">2</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">zlib.crc32</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name"><tt class="docutils literal"><span class="pre">3</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">hashlib.md5</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">4</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">hashlib.sha1</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name"><tt class="docutils literal"><span class="pre">5</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">hashlib.sha224</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">6</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">hashlib.sha256</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name"><tt class="docutils literal"><span class="pre">7</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">hashlib.sha384</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name"><tt class="docutils literal"><span class="pre">8</span></tt>:</th><td class="field-body"><tt class="docutils literal"><span class="pre">hashlib.sha512</span></tt></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field-even field"><th class="field-name">typesize:</th><td class="field-body"><p class="first">(<tt class="docutils literal"><span class="pre">uint8</span></tt>)
The typesize of the data in the chunks. Currently, assume that the typesize
is uniform. The space allocated is the same as in the Blosc header.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">chunk-size:</th><td class="field-body"><p class="first">(<tt class="docutils literal"><span class="pre">int32</span></tt>)
Denotes the chunk-size. Since the maximum buffer size of Blosc is 2GB
having a signed 32 bit int is enough (<tt class="docutils literal"><span class="pre">2GB</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">bytes</span></tt>). The special
value of <tt class="docutils literal"><span class="pre">-1</span></tt> denotes that the chunk-size is unknown or possibly
non-uniform.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">last-chunk:</th><td class="field-body"><p class="first">(<tt class="docutils literal"><span class="pre">int32</span></tt>)
Denotes the size of the last chunk. As with the <tt class="docutils literal"><span class="pre">chunk-size</span></tt> an <tt class="docutils literal"><span class="pre">int32</span></tt>
is enough. Again, <tt class="docutils literal"><span class="pre">-1</span></tt> denotes that this value is unknown.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">nchunks:</th><td class="field-body"><p class="first last">(<tt class="docutils literal"><span class="pre">int64</span></tt>)
The total number of chunks used in the file. Given a chunk-size of one
byte, the total number of chunks is <tt class="docutils literal"><span class="pre">2**63</span></tt>. This amounts to a maximum
file-size of 8EB (<tt class="docutils literal"><span class="pre">8EB</span> <span class="pre">=</span> <span class="pre">2*63</span> <span class="pre">bytes</span></tt>) which should be enough for the next
couple of years. Again, <tt class="docutils literal"><span class="pre">-1</span></tt> denotes that the number of is unknown.</p>
</td>
</tr>
</tbody>
</table>
<p>The overall data-size can be computed as <tt class="docutils literal"><span class="pre">chunk-size</span> <span class="pre">*</span> <span class="pre">(nchunks</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span>
<span class="pre">last-chunk-size</span></tt>. In a streaming scenario <tt class="docutils literal"><span class="pre">-1</span></tt> can be used as a placeholder.
For example if the total number of chunks, or the size of the last chunk is not
known at the time the header is created.</p>
</div>
<div class="section" id="description-of-the-metadata-section">
<h4>Description of the metadata section<a class="headerlink" href="#description-of-the-metadata-section" title="Permalink to this headline">¶</a></h4>
<p>This section goes after the header, and it is just a JSON serialized
version of the metadata that is to be saved.  As JSON has its
limitations as any other serializer, only a subset of Python
structures can be stored, so probably some additional object handling
must be done prior to serialize some metadata.</p>
<p>Example of metadata stored:</p>
<blockquote>
<div>{&#8216;dtype&#8217;: &#8216;varchar&#8217;, &#8216;shape&#8217;: [1024], &#8216;others&#8217;: []}</div></blockquote>
</div>
<div class="section" id="description-of-the-offsets-entries-for-data-items">
<h4>Description of the offsets entries for data items<a class="headerlink" href="#description-of-the-offsets-entries-for-data-items" title="Permalink to this headline">¶</a></h4>
<p>Offsets of the variable length items into the file are used for
stablishing the boundaries between items, and these are mandatory for
variable length data.</p>
<p>Each offset is a 64 bit signed little-endian integer (<tt class="docutils literal"><span class="pre">int64</span></tt>). A
value of <tt class="docutils literal"><span class="pre">-1</span></tt> denotes an unknown offset.  Initially, all offsets
should be initialized to <tt class="docutils literal"><span class="pre">-1</span></tt> and filled in after writing all
items. Thus, if the compression of the file fails prematurely or is
aborted, all offsets should have the value <tt class="docutils literal"><span class="pre">-1</span></tt>.  Each offset
denotes the exact position of the item in the file such that seeking
to the offset, will position the file pointer at the start of the
desired chunk. The layout of this section is then:</p>
<div class="highlight-python"><pre>|-previous-section-|-offset-|-offset-|...|-chunk-|-chunk-|...|</pre>
</div>
</div>
<div class="section" id="description-of-the-chunk-format">
<h4>Description of the chunk format<a class="headerlink" href="#description-of-the-chunk-format" title="Permalink to this headline">¶</a></h4>
<p>A chunk will be keeping one and only one variable length object.</p>
<p>The header for the Blosc chunk has this format (Blosc 1.0 on):</p>
<div class="highlight-python"><pre>|-0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-|-9-|-A-|-B-|-C-|-D-|-E-|-F-|
  ^   ^   ^   ^ |     nbytes    |   blocksize   |    ctbytes    |
  |   |   |   |
  |   |   |   +--typesize
  |   |   +------flags
  |   +----------blosclz version
  +--------------blosc version</pre>
</div>
<p>Following the header there will come the compressed data itself.
Blosc ensures that the compressed buffer will not take more space than
the original one + 16 bytes (the length of the header).</p>
</div>
<div class="section" id="overhead">
<h4>Overhead<a class="headerlink" href="#overhead" title="Permalink to this headline">¶</a></h4>
<p>Depending on which configuration for the file is used a constant, or
linear overhead may be added to the file. The Bloscpack header adds 32
bytes in any case. If the data is non-compressible, Blosc will add 16
bytes of header to each chunk. If used, both the checksum and the
offsets will add overhead to the file. The offsets add 8 bytes per
chunk and the checksum adds a fixed constant value which depends on
the checksum to each chunk. For example, 32 bytes for the <tt class="docutils literal"><span class="pre">adler32</span></tt>
checksum.</p>
<p>Also, depending on the number of reserved bytes at the end of each
chunk (the default is to not reserve them), that will add another
overhead to the final size.</p>
<p>As there will be a chunk for every variable length data object, that
means that it could be in the order of 40 ~ 100 bytes for every data
entry, and that could be a lot for small objects (i.e. one alternate
system must be found for this scenario).</p>
</div>
</div>
</div>
</div>


      </div>
  </div>
</div>
  </body>
</html>