import os
import sys
import time
import array
import ctypes
import numpy as np
from os.path import realpath, dirname, join
from collections import Iterable
from types import ModuleType

import llvm.ee as le

_nptypemap = {
    'c': ctypes.c_char,
    'b': ctypes.c_ubyte,
    'B': ctypes.c_byte,
    'h': ctypes.c_short,
    'H': ctypes.c_ushort,
    'i': ctypes.c_int,
    'I': ctypes.c_uint,
    'l': ctypes.c_long,
    'L': ctypes.c_ulong,
    'f': ctypes.c_float,
    'd': ctypes.c_double,
}

# limited for now
_pytypemap = {
    int   : ctypes.c_int,
    float : ctypes.c_float,
    bool  : ctypes.c_byte,
}

#------------------------------------------------------------------------
# Arguments
#------------------------------------------------------------------------

def array_decon(na):
    ctype = _nptypemap[na.dtype.char]
    _strides = ((s/na.dtype.itemsize) for s in na.strides)

    data = na.ctypes.data_as(ctypes.POINTER(ctype))
    dims = len(na.strides)
    strides = (ctypes.c_int*dims)(*_strides)
    return data, dims, strides

def adapt(arg, val):
    """
    Adapt arguments to run inside ExecutionEngine.
    """
    if isinstance(val, np.ndarray):
        ndarray = arg._type_ # auto-generated by bitey

        data, dims, strides = array_decon(val)
        return ndarray(data, dims, strides)

    elif isinstance(val, array.array):
        raise NotImplementedError

    elif isinstance(val, Iterable):
        # Build an array from an iterable, not the best thing to
        # do performance-wise usually...
        ndarray = arg._type_ # auto-generated by bitey

        ctype = _pytypemap[type(val[0])]

        data = (ctype*len(val))(*val)
        dims = 1
        strides = (ctypes.c_int*1)(len(val))

        return ndarray(data, dims, strides)
    else:
        return val

def wrap_arguments(fn, args):
    if args:
        largs = map(adapt, fn.argtypes, args)
    else:
        largs = ()
    return largs

#------------------------------------------------------------------------
# Toplevel
#------------------------------------------------------------------------

# mostly just delegates to Bitey because I don't feel like rolling a
# ctypes wrapper, this is just for debugging anyways so whatever.
def execute(env, args=None, fname=None, timing=False):
    from bitey.bind import wrap_llvm_module

    args = args or ()

    if os.name == "posix" and sys.platform == "darwin":
        prelude = join(dirname(realpath(__file__)), 'prelude.dylib')
    elif os.name == "posix":
        prelude = join(dirname(realpath(__file__)), 'prelude.so')
    else:
        raise NotImplementedError

    ctypes._dlopen(prelude, ctypes.RTLD_GLOBAL)

    cgen = env['cgen']
    module = cgen.module

    executor = le.ExecutionEngine.new(module)
    executor.run_function(cgen.globals['__module'], [])

    mod = ModuleType('mymodule')
    wrap_llvm_module(cgen.module, executor, mod)

    try:
        lfn = getattr(mod, fname or 'main')
    except AttributeError:
        raise Exception, 'Compiled module has no toplevel function %s' % fname
    largs = wrap_arguments(lfn, args)

    if timing:
        start = time.time()

    res = None
    if len(lfn.argtypes) == 0:
        res = lfn()
    elif len(lfn.argtypes) == len(args):
        res = lfn(*largs)
    else:
        print 'Invalid number of arguments to main function.'

    if timing:
        print 'Time %.6f' % (time.time() - start)

    return res
